package configbuilder

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type configBuilder struct {
	pathToConfig string
	sourcePath   string
	app          string
	fields       []configField
}

func New() *configBuilder {

	return &configBuilder{}
}

type Builder interface {
	SetSourceDir(string) error
	AddField(configField) error
}

func (cb *configBuilder) SetSourceDir(dir string) error {
	st, err := os.Stat(dir)
	if err != nil {
		return fmt.Errorf("set source error: %v", err.Error())
	}
	if !st.IsDir() {
		return fmt.Errorf("set source error: %v is not dir", dir)
	}
	sep := string(filepath.Separator)
	dir = strings.TrimSuffix(dir, sep)
	blocks := strings.Split(dir, sep)
	if len(blocks) < 3 {
		return fmt.Errorf("set source error: dir expected to have at least 2 blocks")
	}
	if blocks[len(blocks)-1] != "config" {
		return fmt.Errorf("set source error: dir name must be 'config' (have '%v')", blocks[len(blocks)-1])
	}
	app := blocks[len(blocks)-2]
	cb.sourcePath = dir + sep + "config.go"
	cb.app = app
	cb.pathToConfig = StdConfigPath(cb.app)

	return nil
}

func (cb *configBuilder) AddField(cf configField, err error) error {
	if err != nil {
		return fmt.Errorf("can't add field: %v", err.Error())
	}
	for _, flds := range cb.fields {
		if flds.sourceField == cf.sourceField {
			return fmt.Errorf("can't add field: field '%v' already set", cf.sourceField)
		}
		if flds.designation == cf.designation {
			return fmt.Errorf("can't add field: designation '%v' already set", cf.designation)
		}
	}
	cb.fields = append(cb.fields, cf)
	return nil
}

func (cb *configBuilder) GenerateSource() string {
	str := ""
	str += "package config\n"
	str += "\n"
	str += "import (\n"
	str += `	"fmt"` + "\n"
	str += `	"os"` + "\n"
	str += `	"path"` + "\n"
	str += `	"path/filepath"` + "\n"
	str += "\n"
	//str += `	"github.com/Galdoba/ffstuff/pkg/configbuilder"` + "\n"
	str += `	"gopkg.in/yaml.v2"` + "\n"

	str += ")\n"
	str += "\n"
	str += "const (\n"
	str += fmt.Sprintf("	appName = "+`"`+"%v"+`"`+"\n", cb.app)
	str += ")\n"
	str += "\n"
	str += "type configuration struct {\n"
	str += "	app	string\n"
	str += "	path	string\n"
	str += "	isCustom	bool\n"
	for _, cf := range cb.fields {
		str += fmt.Sprintf("	%v\n", cf.String())
	}
	str += "}\n"
	str += "\n"
	str += "type ConfigFile interface {\n"
	str += "	Save()	error\n"
	str += "	SaveAs(string)	error\n"
	str += "	Load()	(*configuration, error)\n"
	str += "	LoadCustom(string)	(*configuration, error)\n"
	str += "	Path()	string\n"
	str += "	AppName()	string\n"
	str += "	IsCustom()	bool\n"
	str += "}\n"

	str += "type Config interface {\n"
	str += "	ConfigFile\n"
	for _, cf := range cb.fields {
		str += fmt.Sprintf("	%v()	%v\n", cf.sourceField, cf.valueType)
	}
	str += "}\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "\n////////////NEW-SAVE-LOAD////////////\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "//New - autogenerated constructor of config file\n"
	str += "func New() *configuration {\n"
	str += "	cfg := configuration{}\n"
	str += fmt.Sprintf("	cfg.path = `%v`\n", cb.pathToConfig)
	str += "	cfg.app = appName\n"
	for _, fld := range cb.fields {
		if strings.Contains(fld.valueType, "map[") {
			str += fmt.Sprintf("	cfg.%v = make(%v)\n", fld.sourceField, fld.valueType)
		}
	}
	str += "	return &cfg\n"
	str += "}\n"
	str += "\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "//Save - autogenerated constructor of config file\n"
	str += "func (cfg *configuration) Save() error {\n"
	str += "	data := []byte(header())\n"
	str += "	bt, err := yaml.Marshal(cfg)\n"
	str += "	if err != nil {\n"
	str += "		return err\n"
	str += "	}\n"
	str += "	dir :=  path.Dir(cfg.path)\n"
	str += "	f, err := os.OpenFile(dir, os.O_CREATE|os.O_WRONLY, 0777)\n"
	str += "	if err != nil {\n"
	str += "		return err\n"
	str += "	}\n"
	str += "	defer f.Close()\n"
	str += "	f.Truncate(0)\n"
	str += "	_, err = f.WriteString(header())\n"
	str += "	if err != nil {\n"
	str += "		return fmt.Errorf(" + `"` + "can't save file: write header: " + `%` + `v` + `"` + ", err.Error())\n"
	str += "	}\n"
	str += "	data = append(data, bt...)\n"
	str += "	_, err = f.Write(bt)\n"
	str += "	return err\n"
	str += "}\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "//SaveAs - autogenerated saver of alternative config file\n"
	str += "func (cfg *configuration) SaveAs(path string) error {\n"
	str += "	cfg.path = path\n"
	str += "	cfg.isCustom = true\n"
	str += "	return cfg.Save()\n"
	str += "}\n"
	str += "\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "\n"
	str += "//Load - Load default config\n"
	str += "func Load() (*configuration, error) {\n"
	str += "	path := stdConfigPath()\n"
	str += "	cfg, err := loadConfig(path)\n"
	str += "	if err != nil {\n"
	str += "		return nil,  fmt.Errorf(" + `"can't load default config: ` + `%` + `v"` + ", err.Error())\n"
	str += "	}\n"
	str += "	cfg.isCustom = true\n"
	str += "	return cfg, nil\n"
	str += "}\n"
	str += "\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "//LoadCustom - Loader custom config\n"
	str += "func LoadCustom(path string) (*configuration, error) {\n"
	str += "	cfg, err := loadConfig(path)\n"
	str += "	if err != nil {\n"
	str += "		return nil,  fmt.Errorf(" + `"can't load custom config: ` + `%` + `v"` + ", err.Error())\n"
	str += "	}\n"
	str += "	cfg.isCustom = true\n"
	str += "	return cfg, nil\n"
	str += "}\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "//loadConfig - autogenerated loader config file\n"
	str += "func loadConfig(path string) (*configuration, error) {\n"
	str += "	bt, err := os.ReadFile(path)\n"
	str += "	if err != nil {\n"
	str += "		return nil, fmt.Errorf(" + `"%` + `v"` + ", err.Error())\n"
	str += "	}\n"
	str += "	cfg := &configuration{}\n"
	str += "	err = yaml.Unmarshal(bt, cfg)\n"
	str += "	if err != nil {\n"
	str += "		return nil, fmt.Errorf(" + `"%` + `v"` + ", err.Error())\n"
	str += "	}\n"
	str += "	return cfg, nil\n"
	str += "}\n"

	/////////////////////////////////////////////////////////////////////////////
	str += "\n////////////HELPERS////////////\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "//Path - return filepath of current config\n"
	str += "func (cfg *configuration) Path() string {\n"
	str += "	return cfg.path\n"
	str += "}\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "//IsCustom - return true if config is custom\n"
	str += "func (cfg *configuration) IsCustom() bool {\n"
	str += "	return cfg.isCustom\n"
	str += "}\n"
	/////////////////////////////////////////////////////////////////////////////
	str += "//AppName - return true if config is custom\n"
	str += "func (cfg *configuration) AppName() string {\n"
	str += "	return cfg.app\n"
	str += "}\n"
	str += "\n"

	str += "func stdConfigDir() string {\n"
	str += "	path, err := os.UserHomeDir()\n"
	str += "	if err != nil {\n"
	str += "		panic(err.Error())\n"
	str += "	}\n"
	str += "	sep := string(filepath.Separator)\n"
	str += "	path += sep\n"
	str += "	return path + " + `".config"` + " + sep + appName + sep\n"
	str += "}\n"
	str += "\n"
	str += "func stdConfigPath() string {\n"
	str += "	return stdConfigDir() + " + `"config.yaml"` + "\n"
	str += "}\n"
	str += "\n"

	/////////////////////////////////////////////////////////////////////////////
	str += "\n////////////GETTERS////////////\n"
	for _, cf := range cb.fields {
		str += "\n"
		words := strings.Fields(cf.designation)
		for i := range words {
			letters := strings.Split(words[i], "")
			letters[0] = strings.ToUpper(letters[0])
			words[i] = strings.Join(letters, "")
		}
		funcName := strings.Join(words, "")
		str += fmt.Sprintf("//Get%v - autogenerated getter for '%v' option of config file\n", funcName, strings.TrimSpace(cf.designation))
		str += fmt.Sprintf("func (cfg *configuration) Get%v()	%v {\n", funcName, cf.valueType)
		str += fmt.Sprintf("	return cfg.%v\n", cf.sourceField)
		str += "}\n"
		str += "\n"
	}
	////////////////////////////////////////////////////////////////////////////////

	str += "func header() string {\n"
	str += `	hdr := ""` + "\n"
	for _, s := range strings.Split(cb.headerConstruct(), "\n") {
		str += fmt.Sprintf("	hdr += `"+"%v"+"`\n", s)
	}
	str += "	return hdr\n"
	str += "}\n"

	fmt.Println(str)

	return str
}

//AutoScan          bool     `yaml:"Scan All Files in Tracked Directories  ,omitempty"`
type configField struct {
	sourceField string
	valueType   string
	designation string
	omitempty   bool
}

func NewField(sourceField, valueType, designation string, omitempty bool) (configField, error) {
	if len(sourceField) == 0 {
		return configField{}, fmt.Errorf("'sourcefield' must not be blank")
	}
	switch strings.Split(sourceField, "")[0] {
	case "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z":
	default:
		return configField{}, fmt.Errorf("'sourcefield' must start from large latin letter")
	}
	badCharacters := " `!@#$%^&*()-+|'â„–;%:?	<>" + `"`
	for _, chr := range strings.Split(badCharacters, "") {
		if strings.Contains(sourceField, chr) {
			return configField{}, fmt.Errorf("can't have character '%v' in 'sourcefield'", chr)
		}
	}
	switch {
	default:
		return configField{}, fmt.Errorf("unknown primitive '%v' for valueType (TODO: expand valueType to Support interfaces)", valueType)
	case typeValid(valueType):
	}

	//TODO
	return configField{sourceField, valueType, designation, omitempty}, nil
}

func (cf *configField) String() string {
	oe := ""
	if cf.omitempty {
		oe = ",omitempty"
	}
	return fmt.Sprintf("%v	%v	`yaml:"+`"%v%v"`+"`", cf.sourceField, cf.valueType, cf.designation, oe)
}

//////////HELPERS

func typeValid(tp string) bool {
	primitives := []string{"bool", "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64", "float32", "float64", "complex64", "complex128", "string", "int", "uint", "uintptr", "byte", "rune"}
	allTypes := append([]string{}, primitives...)
	for _, keys := range primitives {
		allTypes = append(allTypes, "[]"+keys)
		for _, vals := range primitives {
			allTypes = append(allTypes, "map["+keys+"]"+vals)
		}
	}
	for _, t := range allTypes {
		if t == tp {
			return true
		}
	}

	return false
}

func StdConfigPath(app string) string {
	return StdConfigDir(app) + "config.yaml"
}

func StdConfigDir(name string) string {
	path, err := os.UserHomeDir()
	if err != nil {
		panic(err.Error())
	}
	sep := string(filepath.Separator)
	path += sep
	return path + ".config" + sep + name + sep
}

func (cb *configBuilder) headerConstruct() string {
	s := "################################################################################\n"
	s += "#              This file was generated by 'configbuilder' package              #\n"
	s += "#                     Check formatting rules before editing                    #\n"
	s += `#                 https://docs.fileformat.com/programming/yaml/                #` + "\n"
	s += "################################################################################\n"
	s += `# expected location: ` + cb.pathToConfig + "\n"
	s += fmt.Sprintf("# app name         : %v\n", cb.app)
	return s
}
