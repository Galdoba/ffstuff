package config

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/Galdoba/utils"
)

const (
	FieldUndefined = "UNDEFINED"
)

type ConfigConstructor struct {
}

/*
config.Construct(
	config.SetField(key, val string),
	config.SetField(key2, val2 string),
)

*/

type Field func(string, string)

type Configer interface {
	SetField(string, string)
}

type File struct {
	location string
	Data     []byte
}

func Construct() (File, error) {
	confDir, file := configPath()
	os.MkdirAll(confDir, os.ModePerm)
	dir, file := configPath()
	f, err := os.OpenFile(dir+"\\"+file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return File{}, err
	}
	defer f.Close()
	exe, err := os.Executable()
	if err != nil {
		fmt.Println(err)
	}
	exe = filepath.Base(exe)
	text := "This is autogenerated config file for " + exe + "\n"
	text += "--------------------------------------------------------------------------------\n"
	fmt.Println("Config constructed:", f.Name())
	if _, err = f.WriteString(text); err != nil {
		return File{}, err
	}

	return File{}, nil
}

func Exists(program string) bool {
	confDir, file := ConfigPathManual(program)
	_, err := os.Stat(confDir + "\\" + file)
	if err != nil {
		fmt.Println(err)
		return false
	}

	return true
}

func Path(program string) bool {
	confDir, file := ConfigPathManual(program)
	_, err := os.Stat(confDir + "\\" + file)
	if err != nil {
		fmt.Println(err)
		return false
	}

	return true
}

func ConstructManual(program string) (File, error) {
	confDir, file := ConfigPathManual(program)
	os.MkdirAll(confDir, os.ModePerm)
	dir, file := ConfigPathManual(program)
	f, err := os.OpenFile(dir+"\\"+file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return File{}, err
	}
	defer f.Close()
	exe, err := os.Executable()
	if err != nil {
		fmt.Println(err)
	}
	exe = filepath.Base(exe)
	text := "#This is autogenerated config file for " + exe + "\n"
	text += "#--------------------------------------------------------------------------------\n"
	fmt.Println("Config constructed:", f.Name())
	if _, err = f.WriteString(text); err != nil {
		return File{location: dir + "\\" + file}, err
	}

	return File{location: dir + "\\" + file}, nil
}

//ConfigFile - return standard config file path
func StandardPath() string {
	dir, file := configPath()
	return dir + "\\" + file
}

func configPath() (string, string) {
	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Println(err)
	}
	configDir := home + "\\.config\\ffstuff"
	return configDir, "ffstuff.config"
}

/*
üÅ£	üÅ§	üÅ•	üÅ¶	üÅß	üÅ®	üÅ©	üÅ™	üÅ´	üÅ¨
*/

func Filepath(program string) string {
	pathSep := string(filepath.Separator)
	dir, name := ConfigPathManual(program)
	return dir + pathSep + name
}

func ConfigPathManual(program string) (string, string) {
	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Println(err)
	}
	pathSep := filepath.Separator
	configDir := home + string(pathSep) + ".config" + string(pathSep) + program
	return configDir, program + ".config"
}

func (f *File) Write(dt []byte) error {
	f.Data = dt
	fmt.Printf("Opening %v...\n", f.location)
	fl, err := os.OpenFile(f.location, os.O_WRONLY, 0600)
	if err != nil {
		return err
	}
	n, err := fl.Write(dt)
	fmt.Println(n, "bytes added")
	if err != nil {
		return err
	}
	return nil
}

//Read - reads config file for this specific program and returns [string]string map
func Read() (configMap map[string]string, err error) {
	confDir, confFile := configPath()
	f, err := os.OpenFile(confDir+"\\"+confFile, os.O_RDONLY, 0600)

	if err != nil {
		fmt.Println(err.Error())
		errStr := err.Error()
		if strings.Contains(errStr, "cannot find the file") {
			return configMap, errors.New("Config file not found")
		}
		if strings.Contains(errStr, "cannot find the path") {
			return configMap, errors.New("Config file not found")
		}
	}
	defer f.Close()
	keyVal := make(map[string]string)
	for _, ln := range utils.LinesFromTXT(f.Name()) {
		k, v := parseKeyValYAML(ln)
		keyVal[k] = v
	}
	//TODO: –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –µ—Å—Ç—å –ª–∏ —Ñ–∞–π–ª
	// return Err.–û—à–∏–±–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –∏ –Ω–∞–ª–∏—á–∏—è —Ñ–∞–π–ª–∞
	//
	//configMap = make(map[string]string)
	//
	//TODO: —Å–æ–±—Ä–∞—Ç—å —Å—Ç—Ä–æ–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞
	// return Err.–û—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
	//

	return keyVal, nil
}

//Read - reads config file for this specific program and returns [string]string map
func ReadFrom(program string) ([]byte, error) {
	confDir, confFile := ConfigPathManual(program)
	f, err := os.OpenFile(confDir+"\\"+confFile, os.O_RDONLY, 0600)

	if err != nil {
		fmt.Println(err.Error())
		errStr := err.Error()
		if strings.Contains(errStr, "cannot find the file") {
			return nil, errors.New("Config file not found")
		}
		if strings.Contains(errStr, "cannot find the path") {
			return nil, errors.New("Config file not found")
		}
	}
	defer f.Close()
	data := []string{}
	for _, ln := range utils.LinesFromTXT(f.Name()) {
		data = append(data, ln)
	}

	return ioutil.ReadFile(confDir + "\\" + confFile)
}

//parseKeyValYAML - Keys are separated from values by a colon+space. Indented blocks, common in YAML data files, use indentation and new lines to separate the key/value pairs.
func parseKeyValYAML(s string) (string, string) {
	kv := strings.Split(s, ": ")
	if len(kv) == 2 {
		return kv[0], kv[1]
	}
	return "", ""
}

func Verify() error {
	dataMap, err := Read()
	if err != nil {
		return err
	}
	und := "Field(s) undefined: "
	for key, val := range dataMap {
		if val == FieldUndefined {
			und += key + ", "
		}
	}
	if und != "Field(s) undefined: " {
		und = strings.TrimSuffix(und, ", ")
		return errors.New(und)
	}
	return nil
}

//Load - search and return config value by key
func Load(key string) (val string, err error) {
	switch runtime.GOOS {
	default:
		return "", errors.New("Unknown OS")
	case "windows":
		Construct()
		return loadFromWindows(key)
	}
}

func loadFromWindows(key string) (val string, err error) {
	fmt.Println(os.UserHomeDir())
	return "", nil
}

func SetField(key, val string) error {
	confDir, file := configPath()
	f, err := os.OpenFile(confDir+"\\"+file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	key = strings.ToUpper(key)
	key = strings.ReplaceAll(key, " ", "_")
	key = strings.TrimSuffix(key, "_")
	// val = strings.ToUpper(val)
	// val = strings.ReplaceAll(val, " ", "_")
	// val = strings.TrimSuffix(val, "_")
	lines := utils.LinesFromTXT(confDir + "\\" + file)
	for n, line := range lines {
		if strings.Contains(line, key+"=") {
			utils.EditLineInFile(confDir+"\\"+file, n, key+"="+val)
			return nil
		}
	}
	if _, err = f.WriteString(key + "=" + val + "\n"); err != nil {
		return err
	}
	return nil
}

func SetFieldManual(program, key, val string) error {
	confDir, file := ConfigPathManual(program)
	f, err := os.OpenFile(confDir+"\\"+file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	key = strings.ToUpper(key)
	key = strings.ReplaceAll(key, " ", "_")
	key = strings.TrimSuffix(key, "_")
	// val = strings.ToUpper(val)
	// val = strings.ReplaceAll(val, " ", "_")
	// val = strings.TrimSuffix(val, "_")
	lines := utils.LinesFromTXT(confDir + "\\" + file)
	for n, line := range lines {
		if strings.Contains(line, key+"=") {
			utils.EditLineInFile(confDir+"\\"+file, n, key+"="+val)
			return nil
		}
	}
	if _, err = f.WriteString(key + ": " + val + "\n"); err != nil {
		return err
	}
	return nil
}

func AddCommentManual(program, comment string) error {
	confDir, file := ConfigPathManual(program)
	f, err := os.OpenFile(confDir+"\\"+file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	if _, err = f.WriteString("#" + comment + "\n"); err != nil {
		return err
	}
	return nil
}

type Config struct {
	Program string
	Path    string
	Field   map[string]string
}

func ReadProgramConfig(program string) (Config, error) {
	conf := Config{}
	conf.Program = program
	conf.Field = make(map[string]string)
	dirW, dirL, file := configPathLocked(program)
	conf.Path = dirW + "\\" + file
	f, err := os.OpenFile(conf.Path, os.O_RDONLY, 0600)
	errStr := ""
	if err != nil {
		//fmt.Println("Try 1", err.Error())
		errStr = err.Error()
	}
	if errStr != "" {
		errStr = ""
		conf.Path = dirL + "\\" + file
		f, err = os.OpenFile(conf.Path, os.O_RDONLY, 0600)
		if err != nil {
			//	fmt.Println("Try 2", err.Error())
			errStr = err.Error()
		}
	}
	if strings.Contains(errStr, "cannot find the file") {
		return conf, errors.New("Config file not found")
	}
	if strings.Contains(errStr, "cannot find the path") {
		return conf, errors.New("Config file not found")
	}

	defer f.Close()
	for _, ln := range utils.LinesFromTXT(f.Name()) {
		k, v := parseKeyValYAML(ln)
		conf.Field[k] = v
	}
	delete(conf.Field, "")
	return conf, nil
}

func configPathLocked(programName string) (string, string, string) {
	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Println(err)
	}

	configDirWN := ""
	configDirLN := ""
	switch runtime.GOOS {
	case "windows":

		configDirWN = home + "\\config\\" + programName  // + exe + ".config"
		configDirLN = home + "\\.config\\" + programName // + exe + ".config"

	}
	return configDirWN, configDirLN, programName + ".config"
}

/*
UserHome/Dev/Prog/
*/

func SetDefault() error {
	confDir, file := configPath()
	os.MkdirAll(confDir, os.ModePerm)
	f, err := os.OpenFile(confDir+"\\"+file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return err
	}
	defer f.Close()
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	text := "This is autogenerated config file for collection of ffstuff tools\n"
	text += "--------------------------------------------------------------------------------\n"
	text += `DefaultGrabberDestination: d:\GATEWAY\` + "\n"
	text += `LogsFilesDirectory: AUTO` + "\n"
	text += `SearchRoot: \\192.168.31.4\root\EDIT\` + "\n"
	text += `SearchMarker: .ready` + "\n"
	text += `StatisticDirectory: AUTO` + "\n"
	text += `SpreadsheetCurl: --use-ascii --proxy "http://proxy.local:3128" https://docs.google.com/spreadsheets/d/1Waa58usrgEal2Da6tyayaowiWujpm0rzd06P5ASYlsg/gviz/tq?tqx=out:tsv -k --output ` + "\n"
	text += `SpreadsheetDataPath: ` + home + `\.ffstuff\data\taskSpreadsheet.csv` + "\n"
	if _, err = f.WriteString(text); err != nil {
		return err
	}
	fmt.Println("Config constructed")
	return nil
}

/*
CONFIG FIELDS:
DefaultGrabberDestination:
DefaultLogsDirectory:
SearchRoot:
SearchMarker:
StatisticDirectory:

*/

func ReadConfig() (Config, error) {
	conf := Config{}
	conf.Program = "ffstuff"
	conf.Field = make(map[string]string)
	dir, file := configPath()
	conf.Path = dir + "\\" + file
	f, err := os.OpenFile(conf.Path, os.O_RDONLY, 0600)
	if err != nil {
		return conf, err
	}
	defer f.Close()
	for _, ln := range utils.LinesFromTXT(f.Name()) {
		k, v := parseKeyValYAML(ln)
		conf.Field[k] = v
		//fmt.Printf("Field[%v]=%v\n", k, v)
	}
	delete(conf.Field, "")
	return conf, nil
}
