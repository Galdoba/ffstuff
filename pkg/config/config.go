package config

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/Galdoba/utils"
)

const (
	FieldUndefined = "UNDEFINED"
)

type ConfigConstructor struct {
}

/*
config.Construct(
	config.SetField(key, val string),
	config.SetField(key2, val2 string),
)

*/

type Field func(string, string)

type Configer interface {
	SetField(string, string)
}

type File struct{}

func Construct() (File, error) {
	confDir, file := configPath()
	os.MkdirAll(confDir, os.ModePerm)
	dir, file := configPath()
	f, err := os.OpenFile(dir+"\\"+file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return File{}, err
	}
	defer f.Close()
	exe, err := os.Executable()
	if err != nil {
		fmt.Println(err)
	}
	exe = filepath.Base(exe)
	text := "This is autogenerated config file for " + exe + "\n"
	text += "--------------------------------------------------------------------------------\n"
	fmt.Println("Config constructed:", f.Name())
	if _, err = f.WriteString(text); err != nil {
		return File{}, err
	}

	return File{}, nil
}

//ConfigFile - return standard config file path
func StandardPath() string {
	dir, file := configPath()
	return dir + "\\" + file
}

func configPath() (string, string) {
	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Println(err)
	}
	exe, err := os.Executable()
	if err != nil {
		fmt.Println(err)
	}
	exe = filepath.Base(exe)
	configDir := ""
	switch runtime.GOOS {
	case "windows":
		exe = strings.TrimSuffix(exe, ".exe")
		configDir = home + "\\config\\" + exe // + exe + ".config"

	}
	return configDir, exe + ".config"
}

//Read - reads config file for this specific program and returns [string]string map
func Read() (configMap map[string]string, err error) {
	confDir, confFile := configPath()
	f, err := os.OpenFile(confDir+"\\"+confFile, os.O_RDONLY, 0600)

	if err != nil {
		fmt.Println(err.Error())
		errStr := err.Error()
		if strings.Contains(errStr, "cannot find the file") {
			return configMap, errors.New("Config file not found")
		}
		if strings.Contains(errStr, "cannot find the path") {
			return configMap, errors.New("Config file not found")
		}
	}
	defer f.Close()
	keyVal := make(map[string]string)
	for _, ln := range utils.LinesFromTXT(f.Name()) {
		k, v := parseKeyValYAML(ln)
		keyVal[k] = v
	}
	//TODO: проверить есть ли файл
	// return Err.Ошибки доступа и наличия файла
	//
	//configMap = make(map[string]string)
	//
	//TODO: собрать строки из файла
	// return Err.Ошибки парсинга
	//

	return keyVal, nil
}

//parseKeyValYAML - Keys are separated from values by a colon+space. Indented blocks, common in YAML data files, use indentation and new lines to separate the key/value pairs.
func parseKeyValYAML(s string) (string, string) {
	kv := strings.Split(s, ": ")
	if len(kv) == 2 {
		return kv[0], kv[1]
	}
	return "", ""
}

func Verify() error {
	dataMap, err := Read()
	if err != nil {
		return err
	}
	und := "Field(s) undefined: "
	for key, val := range dataMap {
		if val == FieldUndefined {
			und += key + ", "
		}
	}
	if und != "Field(s) undefined: " {
		und = strings.TrimSuffix(und, ", ")
		return errors.New(und)
	}
	return nil
}

//Load - search and return config value by key
func Load(key string) (val string, err error) {
	switch runtime.GOOS {
	default:
		return "", errors.New("Unknown OS")
	case "windows":
		Construct()
		return loadFromWindows(key)
	}
}

func loadFromWindows(key string) (val string, err error) {
	fmt.Println(os.UserHomeDir())
	return "", nil
}

func SetField(key, val string) error {
	confDir, file := configPath()
	f, err := os.OpenFile(confDir+"\\"+file, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	key = strings.ToUpper(key)
	key = strings.ReplaceAll(key, " ", "_")
	key = strings.TrimSuffix(key, "_")
	// val = strings.ToUpper(val)
	// val = strings.ReplaceAll(val, " ", "_")
	// val = strings.TrimSuffix(val, "_")
	lines := utils.LinesFromTXT(confDir + "\\" + file)
	for n, line := range lines {
		if strings.Contains(line, key+"=") {
			utils.EditLineInFile(confDir+"\\"+file, n, key+"="+val)
			return nil
		}
	}
	if _, err = f.WriteString(key + "=" + val + "\n"); err != nil {
		return err
	}
	return nil
}

type Config struct {
	Program string
	Path    string
	Field   map[string]string
}

func ReadProgramConfig(program string) (Config, error) {
	conf := Config{}
	conf.Program = program
	conf.Field = make(map[string]string)
	dirW, dirL, file := configPathLocked(program)
	conf.Path = dirW + "\\" + file
	f, err := os.OpenFile(conf.Path, os.O_RDONLY, 0600)
	errStr := ""
	if err != nil {
		//fmt.Println("Try 1", err.Error())
		errStr = err.Error()
	}
	if errStr != "" {
		errStr = ""
		conf.Path = dirL + "\\" + file
		f, err = os.OpenFile(conf.Path, os.O_RDONLY, 0600)
		if err != nil {
			//	fmt.Println("Try 2", err.Error())
			errStr = err.Error()
		}
	}
	if strings.Contains(errStr, "cannot find the file") {
		return conf, errors.New("Config file not found")
	}
	if strings.Contains(errStr, "cannot find the path") {
		return conf, errors.New("Config file not found")
	}

	defer f.Close()
	for _, ln := range utils.LinesFromTXT(f.Name()) {
		k, v := parseKeyValYAML(ln)
		conf.Field[k] = v
	}
	delete(conf.Field, "")
	return conf, nil
}

func configPathLocked(programName string) (string, string, string) {
	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Println(err)
	}

	configDirWN := ""
	configDirLN := ""
	switch runtime.GOOS {
	case "windows":

		configDirWN = home + "\\config\\" + programName  // + exe + ".config"
		configDirLN = home + "\\.config\\" + programName // + exe + ".config"

	}
	return configDirWN, configDirLN, programName + ".config"
}

/*
UserHome/Dev/Prog/
*/
